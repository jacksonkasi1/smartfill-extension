// ** import types
import type { AIFormData, FormField } from '@/types/extension'

// ** import constants
import {
  AI_PROVIDERS,
  DEFAULT_AI_PROVIDER,
  GEMINI_API_BASE_URL,
  type AIProviderConfig,
  type AIProviderKey
} from './constants'

// ** import utils
import { buildPrompt } from './prompt'
import { parseAIResponse } from './parser'

function getStorageKeys(): string[] {
  const providerKeys = Object.values(AI_PROVIDERS).flatMap((provider) => [
    provider.keyStorage,
    provider.modelStorage
  ])
  return ['aiProvider', ...providerKeys]
}

function resolveProvider(key: unknown): AIProviderKey {
  if (typeof key === 'string' && key in AI_PROVIDERS) {
    return key as AIProviderKey
  }
  return DEFAULT_AI_PROVIDER
}

export async function generateFormData(fields: FormField[], customPrompt?: string): Promise<AIFormData> {
  const result = await chrome.storage.sync.get(getStorageKeys())

  const providerKey = resolveProvider(result.aiProvider)
  const providerConfig = AI_PROVIDERS[providerKey]

  const apiKeyRaw = result[providerConfig.keyStorage]
  const apiKey = typeof apiKeyRaw === 'string' ? apiKeyRaw.trim() : ''
  if (!apiKey) {
    throw new Error(`No API key configured for ${providerConfig.label}`)
  }

  const storedModel = result[providerConfig.modelStorage]
  const model = typeof storedModel === 'string' && storedModel.trim()
    ? storedModel.trim()
    : providerConfig.defaultModel

  const prompt = buildPrompt(fields, customPrompt)

  let generatedText: string
  if (providerConfig.type === 'gemini') {
    generatedText = await callGemini(apiKey, model, prompt)
  } else {
    generatedText = await callOpenAICompatible(providerConfig, apiKey, model, prompt)
  }

  if (!generatedText) {
    throw new Error(`No content generated by ${providerConfig.label}`)
  }

  return parseAIResponse(generatedText, fields)
}

async function callGemini(apiKey: string, model: string, prompt: string): Promise<string> {
  const url = `${GEMINI_API_BASE_URL}/${model}:generateContent?key=${apiKey}`
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      contents: [
        {
          parts: [
            {
              text: prompt
            }
          ]
        }
      ]
    })
  })

  if (!response.ok) {
    const errorMessage = await extractErrorMessage(response, 'Gemini API error')
    throw new Error(errorMessage)
  }

  const data = await response.json()
  return data.candidates?.[0]?.content?.parts?.[0]?.text ?? ''
}

async function callOpenAICompatible(
  providerConfig: AIProviderConfig,
  apiKey: string,
  model: string,
  prompt: string
): Promise<string> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    Authorization: `Bearer ${apiKey}`
  }

  if (providerConfig.extraHeaders) {
    Object.assign(headers, providerConfig.extraHeaders)
  }

  const response = await fetch(providerConfig.endpoint, {
    method: 'POST',
    headers,
    body: JSON.stringify({
      model,
      messages: [
        {
          role: 'system',
          content: 'You are a helpful form filling assistant. Always respond with valid JSON only.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.2
    })
  })

  if (!response.ok) {
    const errorMessage = await extractErrorMessage(response, `${providerConfig.label} API error`)
    throw new Error(errorMessage)
  }

  const data = await response.json()
  const firstChoice = data?.choices?.[0]
  const message = firstChoice?.message

  if (!message) {
    return ''
  }

  if (Array.isArray(message.content)) {
    return message.content
      .map((part: unknown) => {
        if (typeof part === 'string') return part
        if (part && typeof part === 'object' && 'text' in part) {
          return String((part as { text?: string }).text ?? '')
        }
        return ''
      })
      .join('')
      .trim()
  }

  return typeof message.content === 'string' ? message.content : ''
}

async function extractErrorMessage(response: Response, fallback: string): Promise<string> {
  try {
    const errorData = await response.json()
    if (errorData?.error?.message) {
      return errorData.error.message
    }
    if (typeof errorData?.message === 'string') {
      return errorData.message
    }
  } catch {
    // Ignore JSON parsing errors
  }
  return `${fallback}: ${response.status} ${response.statusText}`
}
